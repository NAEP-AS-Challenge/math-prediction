<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>rud_file_import_syntax</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="RUD_file_import_syntax_files/libs/clipboard/clipboard.min.js"></script>
<script src="RUD_file_import_syntax_files/libs/quarto-html/quarto.js"></script>
<script src="RUD_file_import_syntax_files/libs/quarto-html/popper.min.js"></script>
<script src="RUD_file_import_syntax_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="RUD_file_import_syntax_files/libs/quarto-html/anchor.min.js"></script>
<link href="RUD_file_import_syntax_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="RUD_file_import_syntax_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="RUD_file_import_syntax_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="RUD_file_import_syntax_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="RUD_file_import_syntax_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="importing-the-data-into-r-or-python" class="level1">
<h1>Importing the data into R or Python</h1>
<p>We have provided the data in two formats. For importing easily in to R, we provide an <code>*.rda</code> format file. We strongly recommend using this file if you plan to work in R. We have also provided the data as a tab delimited text file. We assume most people who are not working in R will use Python and have created the text file format version with that in mind. Of course, the text file can be opened in Excel or OpenOffice and many other software systems, but we have not tested beyond R and Python.</p>
<p>If using the text file, it’s important to know that the original data have non-ascii (or extended “high” ascii) characters that require UTF-8 encoding to maintain full fidelity to the original, for example, mathematical operators and symbols like the pi symbol (<span class="math inline">\(\pi\)</span>), multiplication sign (<span class="math inline">\(\times\)</span>), greater-than-or-equal-to, etc… Because of this, to safely export the data from R to tab delimited text files, we’ve used the R <code>readr</code> package’s <code>write_excel_csv()</code> function, which writes faithfully encoded UTF-8 data on our Windows platform. This package also adds the appropriate UTF-8 BOM to help ensure the file will be read correctly by other software. We have tested that the text files written this way can be imported back into R (using the analogous <code>readr::read_delim()</code> function with default settings), and that after the text file is read back into R it matches the original.</p>
<section id="reading-the-data-into-python" class="level2">
<h2 class="anchored" data-anchor-id="reading-the-data-into-python">Reading the data into Python</h2>
<p>We suggest importing the tab delimited text files into Python using the Pandas <code>read_csv()</code> function. While there are many ways to read the data, we have only tested reading the delimited file with Pandas <code>read_csv()</code> with the <code>"\t"</code> delimiter option (see syntax below). That is the method we recommend, though there may be many other ways that work just as well (e.g.&nbsp;Polars’ read_csv()).</p>
<p>We caution against reading the R (*.rda) format file into Python directly, because the tests we performed using <code>pyreadr</code> package to read the R file directly showed discrepancies when tested against a file exported from R into the arrow ipc binary format (which we are not releasing). We strongly recommend not using <code>pyreadr</code>, but using Pandas read_csv as shown in the sytnax below.</p>
<section id="python-syntax-for-reading-tab-delimited-file" class="level3">
<h3 class="anchored" data-anchor-id="python-syntax-for-reading-tab-delimited-file">Python syntax for reading tab delimited file</h3>
<section id="tested-on-python-3.7" class="level4">
<h4 class="anchored" data-anchor-id="tested-on-python-3.7">(tested on Python 3.7)</h4>
<pre><code>import pandas as pd
import csv, os 

os.chdir(r"path_to_files" +"\\")

# use Int64 rather than int since it allows NA values
dtypelist =  {
 "student_id"         :str,
 "accession"          :str,
 "score_to_predict"   :"Int64",
 "predict_from"       :str,
 "year"               :str,
 "srace10"            :"Int64",
 "dsex"               :"Int64",
 "accom2"             :"Int64",
 "iep"                :"Int64",
 "lep"                :"Int64",
 "rater_1"            :str,
 "pta_rtr1"           :str,
 "ptb_rtr1"           :str,
 "ptc_rtr1"           :str,
 "composite"          :str,
 "score"              :str,
 "assigned_score"     :"Int64",
 "ee_use"             :"Int64",
 "parsed_xml_v1"      :str,
 "parsed_xml_v2"      :str,
 "parsed_xml_v3"      :str,
 "source1"            :str,
 "source2"            :str,
 "source3"            :str,
 "source4"            :str,
 "target1"            :str,
 "target2"            :str,
 "target3"            :str,
 "target4"            :str,
 "eliminations"       :str,
 "selected"           :str,
 "eliminated"         :str,
 "selected1"          :str,
 "selected2"          :str,
 "selected3"          :str,
 "selected4"          :str,
 "eliminated1"        :str,
 "eliminated2"        :str,
 "eliminated3"        :str,
 "eliminated4"        :str,
 "selected1.1"        :str,
 "selected2.1"        :str,
 "eliminated1.1"      :str,
 "eliminated2.1"      :str,
 "partA_response_val" :str,
 "partB_response_val" :str,
 "partB_eliminations" :str,
 "response_val"       :str,
 "response_val.1"     :str,
 "response_val.2"     :str}

 x = pd.read_csv("all_items_train_2023-02-17.txt", sep='\t', dtype=dtypelist, na_values= ['N/A', 'NA', 'NULL', 'NaN', 'n/a', 'nan', 'null',''])</code></pre>
<p>Even with this syntax there may be slight differences to the coding of missing values between R and Python (“NA” missing values in R may be “NaN” or “None” in Python), but the contents of the files, and most importantly the text of student constructed responses and values of forced choice responses, will match.</p>
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>